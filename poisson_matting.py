# -*- coding: utf-8 -*-
"""poisson_matting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HxhSLtaRHIXdRA4Z-gIAw-9JDnj-6c-p
"""

from __future__ import division
import numpy as np
import scipy.misc
import scipy.ndimage
import matplotlib.pyplot as plt
import cv2
import time
from numba import jit
import imageio
import PIL
class Poisson_Matting():
    def Matting(self,img, trimap):
        self.h, self.w ,c  = img.shape

        gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

        fg = trimap == 255
        bg = trimap == 0
        self.unknown = True ^ np.logical_or(fg,bg)
        img = img
        fg_img = gray_img*fg
        bg_img = gray_img*bg
        alphaEstimate = fg + 0.5 * self.unknown

        approx_bg = cv2.inpaint(bg_img.astype(np.uint8),(self.unknown +fg ).astype(np.uint8)*255,3,cv2.INPAINT_TELEA)*(np.logical_not(fg)).astype(np.float32)
        approx_fg = cv2.inpaint(fg_img.astype(np.uint8),(self.unknown +bg ).astype(np.uint8)*255,3,cv2.INPAINT_TELEA)*(np.logical_not(bg)).astype(np.float32)
        '''
        plt.imshow(self.unknown, cmap='gray')
        plt.show()
        plt.imshow(approx_fg, cmap='gray')
        plt.show()
        plt.imshow(approx_bg, cmap='gray')
        plt.show()
        '''
        # Smooth F - B image
        approx_diff = approx_fg - approx_bg
        approx_diff = scipy.ndimage.filters.gaussian_filter(approx_diff, 0.9)

        dy, dx = np.gradient(gray_img)

        d2y, _ = np.gradient(dy/approx_diff)
        _, d2x = np.gradient(dx/approx_diff)

        b = d2y + d2x

        alpha = self.computeAlphaJit(alphaEstimate, b)
        alpha = np.minimum(np.maximum(alpha,0),1).reshape(self.h,self.w)

        #plt.imshow(alpha, cmap='gray')
        #plt.show()
        #plt.imshow((alpha.reshape(self.h,self.w,1).repeat(3,2)*img).astype(np.uint8))
        #plt.show()

        return alpha

    def computeAlphaSlow(alpha, b):
        alphaNew = alpha.copy()
        alphaOld = np.zeros(alphaNew.shape)
        threshold = 0.1
        n = 1
        while (n < 50 and np.sum(np.abs(alphaNew - alphaOld)) > threshold):
            alphaOld = alphaNew.copy()
            for i in range(1, h-1):
                for j in range(1, w-1):
                    if(self.unknown[i,j]):
                        alphaNew[i,j] = 1/4  * (alphaNew[i-1 ,j] + alphaNew[i,j-1] + alphaOld[i, j+1] + alphaOld[i+1,j] - b[i,j])
            n +=1
        return alphaNew

    @jit
    def computeAlphaJit(self,alpha, b):
        alphaNew = alpha.copy()
        alphaOld = np.zeros(alphaNew.shape)
        threshold = 0.1
        n = 1
        while (n < 50 and np.sum(np.abs(alphaNew - alphaOld)) > threshold):
            alphaOld = alphaNew.copy()
            for i in range(1, self.h-1):
                for j in range(1, self.w-1):
                    if(self.unknown[i,j]):
                        alphaNew[i,j] = 1/4  * (alphaNew[i-1 ,j] + alphaNew[i,j-1] + alphaOld[i, j+1] + alphaOld[i+1,j] - b[i,j])
            n +=1
        return alphaNew

    def computeAlpha(alpha, b):
        alphaNew = alpha.copy()
        alphaOld = np.zeros(alphaNew.shape)
        threshold = 0.1
        n = 1
        ca = np.transpose(np.nonzero(self.unknown))
        c = ca[ (ca[:,0]>=1) & (ca[:,0]<h-1) &  (ca[:,1]>=1) & (ca[:,1]<w-1)]
        c0 = c[:,0]
        c1 = c[:,1]
        while (n < 50 and np.sum(np.abs(alphaNew - alphaOld)) > threshold):
            alphaOld = alphaNew.copy()
            alphaNew[c0, c1] = 1/4  * (alphaNew[c0 -1, c1] + alphaNew[c0, c1 -1] + alphaOld[c0,c1+1] + alphaOld[c0+1,c1] - b[c0,c1])
            n +=1
        return alphaNew